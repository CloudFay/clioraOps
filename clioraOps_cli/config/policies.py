"""
Security policy system for ClioraOps.

Controls file access, resource usage, and security boundaries.
"""

import os
import yaml
from pathlib import Path
from typing import List, Dict, Optional
from enum import Enum


class PolicyLevel(Enum):
    """Security policy levels."""
    PERMISSIVE = "permissive"  # Allow most operations
    MODERATE = "moderate"      # Standard security
    STRICT = "strict"          # Restricted operations
    SANDBOX = "sandbox"        # Locked down


class AccessPolicy:
    """
    File and directory access control policy.
    
    Defines what files and directories can be accessed, modified,
    or generated by ClioraOps.
    """
    
    def __init__(self, policy_dict: Optional[Dict] = None):
        """
        Initialize policy from dictionary.
        
        Args:
            policy_dict: Policy configuration (if None, uses defaults)
        """
        self.policy = policy_dict or self._default_policy()
        self.level = PolicyLevel(self.policy.get("level", "moderate"))
        
    @staticmethod
    def _default_policy() -> Dict:
        """Get default security policy."""
        return {
            "level": "moderate",
            "allowed_paths": [
                str(Path.home() / ".clioraops"),
                str(Path.cwd()),
                "/tmp",
                "/var/tmp",
            ],
            "blocked_paths": [
                "/etc",
                "/root",
                "/sys",
                "/proc",
                "/boot",
            ],
            "allowed_file_types": [
                ".py", ".yaml", ".yml", ".json", ".txt", ".md",
                ".sh", ".dockerfile", ".dockerfile",
                ".tf", ".tfvars",
                ".yml", ".yaml",
                ".xml", ".toml",
            ],
            "blocked_file_types": [
                ".exe", ".bin", ".so",
            ],
            "max_file_size_mb": 100,
            "max_generated_files": 1000,
            "file_creation_allowed": True,
            "file_modification_allowed": True,
            "file_deletion_allowed": False,
            "symlink_creation_allowed": False,
        }
    
    @staticmethod
    def load_from_file(filepath: Path) -> "AccessPolicy":
        """
        Load policy from YAML file.
        
        Args:
            filepath: Path to policy YAML file
            
        Returns:
            AccessPolicy instance
        """
        try:
            if filepath.exists():
                with open(filepath, 'r') as f:
                    policy_dict = yaml.safe_load(f) or {}
                return AccessPolicy(policy_dict)
        except Exception:
            pass
        
        return AccessPolicy()  # Return default on error
    
    def is_path_allowed(self, path: str) -> bool:
        """
        Check if a path is allowed.
        
        Args:
            path: File or directory path to check
            
        Returns:
            True if path is allowed, False otherwise
        """
        abs_path = str(Path(path).absolute())
        
        # Check blocked paths
        for blocked in self.policy.get("blocked_paths", []):
            if abs_path.startswith(blocked):
                return False
        
        # Check allowed paths
        allowed = self.policy.get("allowed_paths", [])
        if allowed:
            for allowed_path in allowed:
                if abs_path.startswith(allowed_path):
                    return True
            return False
        
        return True
    
    def is_file_type_allowed(self, filename: str) -> bool:
        """
        Check if file type is allowed.
        
        Args:
            filename: Name of file to check
            
        Returns:
            True if file type is allowed, False otherwise
        """
        _, ext = os.path.splitext(filename)
        
        # Check blocked types
        blocked = self.policy.get("blocked_file_types", [])
        if ext.lower() in blocked:
            return False
        
        # Check allowed types (if list is defined)
        allowed = self.policy.get("allowed_file_types", [])
        if allowed and ext.lower() not in allowed:
            return False
        
        return True
    
    def is_file_size_allowed(self, size_bytes: int) -> bool:
        """
        Check if file size is within limits.
        
        Args:
            size_bytes: File size in bytes
            
        Returns:
            True if size is allowed, False otherwise
        """
        max_mb = self.policy.get("max_file_size_mb", 100)
        max_bytes = max_mb * 1024 * 1024
        return size_bytes <= max_bytes
    
    def can_create_files(self) -> bool:
        """Check if file creation is allowed."""
        return self.policy.get("file_creation_allowed", True)
    
    def can_modify_files(self) -> bool:
        """Check if file modification is allowed."""
        return self.policy.get("file_modification_allowed", True)
    
    def can_delete_files(self) -> bool:
        """Check if file deletion is allowed."""
        return self.policy.get("file_deletion_allowed", False)
    
    def can_create_symlinks(self) -> bool:
        """Check if symlink creation is allowed."""
        return self.policy.get("symlink_creation_allowed", False)
    
    def is_operation_allowed(self, operation: str, path: str = None, size: int = None) -> bool:
        """
        Comprehensive check for whether an operation is allowed.
        
        Args:
            operation: Type of operation (create, modify, delete, execute)
            path: File path (if applicable)
            size: File size in bytes (if applicable)
            
        Returns:
            True if operation is allowed, False otherwise
        """
        # Check path if provided
        if path and not self.is_path_allowed(path):
            return False
        
        # Check file type if path provided
        if path and not self.is_file_type_allowed(path):
            return False
        
        # Check file size if size provided
        if size and not self.is_file_size_allowed(size):
            return False
        
        # Check operation-specific permissions
        if operation == "create":
            return self.can_create_files()
        elif operation == "modify":
            return self.can_modify_files()
        elif operation == "delete":
            return self.can_delete_files()
        
        return True
    
    def get_policy_summary(self) -> str:
        """Get human-readable policy summary."""
        lines = [
            f"Security Level: {self.level.value.upper()}",
            f"File Creation: {'✅ Allowed' if self.can_create_files() else '❌ Blocked'}",
            f"File Modification: {'✅ Allowed' if self.can_modify_files() else '❌ Blocked'}",
            f"File Deletion: {'✅ Allowed' if self.can_delete_files() else '❌ Blocked'}",
            f"Symlink Creation: {'✅ Allowed' if self.can_create_symlinks() else '❌ Blocked'}",
            f"Max File Size: {self.policy.get('max_file_size_mb', 100)} MB",
        ]
        
        allowed_paths = self.policy.get("allowed_paths", [])
        if allowed_paths:
            lines.append(f"Allowed Paths: {', '.join(allowed_paths[:3])}")
        
        blocked_paths = self.policy.get("blocked_paths", [])
        if blocked_paths:
            lines.append(f"Blocked Paths: {', '.join(blocked_paths[:3])}")
        
        return "\n".join(lines)


def load_policy() -> AccessPolicy:
    """
    Load policy from user config or use default.
    
    Priority:
    1. User policy file (~/.clioraops/policy.yaml)
    2. Project policy file (./.clioraops-policy.yaml)
    3. Default policy
    
    Returns:
        AccessPolicy instance
    """
    # Try user policy
    user_policy = Path.home() / ".clioraops" / "policy.yaml"
    if user_policy.exists():
        return AccessPolicy.load_from_file(user_policy)
    
    # Try project policy
    project_policy = Path.cwd() / ".clioraops-policy.yaml"
    if project_policy.exists():
        return AccessPolicy.load_from_file(project_policy)
    
    # Return default
    return AccessPolicy()


def create_default_policy_file() -> None:
    """Create default policy file in user config directory."""
    config_dir = Path.home() / ".clioraops"
    policy_file = config_dir / "policy.yaml"
    
    config_dir.mkdir(parents=True, exist_ok=True)
    
    if policy_file.exists():
        return
    
    default_policy = AccessPolicy()
    
    with open(policy_file, 'w') as f:
        yaml.dump(default_policy.policy, f, default_flow_style=False)
