"""
ArchitectureVisualizer Module for ClioraOps

Generates visual architecture diagrams in multiple formats:
- ASCII art for quick CLI viewing
- PNG/SVG diagrams using diagrams library
- Mermaid diagrams for documentation

Provides educational explanations for each architecture pattern.
"""

from typing import Dict, List, Optional, Tuple
from pathlib import Path
import subprocess
import sys

from clioraOps_cli.features.models import DiagramFormat, ArchitecturePattern, DiagramResult
from clioraOps_cli.features.ascii_gen import ASCIIArtGenerator
from clioraOps_cli.features.visualizer_explanations import get_explanation


class ArchitectureVisualizer:
    """
    Main visualizer class for generating architecture diagrams.
    """
    
    def __init__(self, mode=None, ai=None):
        """Initialize the visualizer."""
        self.mode = mode
        self.ai = ai
        self.ascii_generator = ASCIIArtGenerator()
        self._check_dependencies()
    
    def _check_dependencies(self) -> Dict[str, bool]:
        """Check if optional diagram libraries are available."""
        dependencies = {
            "diagrams": False,
            "graphviz": False,
        }
        
        try:
            import diagrams
            dependencies["diagrams"] = True
        except ImportError:
            pass
        
        try:
            result = subprocess.run(
                ["which", "dot"],
                capture_output=True,
                text=True
            )
            dependencies["graphviz"] = result.returncode == 0
        except Exception:
            pass
        
        return dependencies
    
    def generate(
        self,
        pattern: ArchitecturePattern,
        output_format: DiagramFormat = DiagramFormat.ASCII,
        output_path: Optional[str] = None,
        include_explanation: bool = True
    ) -> DiagramResult:
        """
        Generate an architecture diagram.
        
        Args:
            pattern: Architecture pattern to visualize
            output_format: Output format (ASCII, PNG, SVG, MERMAID)
            output_path: Path to save diagram (for PNG/SVG)
            include_explanation: Include educational explanation
            
        Returns:
            DiagramResult with diagram and metadata
        """
        if output_format == DiagramFormat.ASCII:
            return self._generate_ascii(pattern, include_explanation)
        elif output_format == DiagramFormat.MERMAID:
            return self._generate_mermaid(pattern, include_explanation)
        elif output_format in [DiagramFormat.PNG, DiagramFormat.SVG]:
            return self._generate_image(pattern, output_format, output_path, include_explanation)
    def generate_custom(
        self,
        topic: str,
        output_format: DiagramFormat = DiagramFormat.ASCII,
        include_explanation: bool = True
    ) -> DiagramResult:
        """
        Generate a custom architecture diagram using AI.
        """
        if not self.ai:
            return DiagramResult(
                success=False,
                format=output_format,
                error="AI assistance not available. Provide a built-in pattern or enable AI."
            )
            
        print(f"ü§ñ AI is designing: {topic}...")
        
        prompt = self._build_design_prompt(topic, output_format)
        response = self.ai.chat(prompt)
        
        if not response.success:
            return DiagramResult(
                success=False,
                format=output_format,
                error=f"AI generation failed: {response.content}"
            )
            
        content = response.content
        ascii_out = ""
        mermaid_out = ""
        explanation = ""
        
        # Simple extraction logic
        if output_format == DiagramFormat.ASCII:
            ascii_out = self._extract_block(content, "ascii") or content
        elif output_format == DiagramFormat.MERMAID:
            mermaid_out = self._extract_block(content, "mermaid") or content
            
        if include_explanation:
            explanation = self._extract_block(content, "explanation") or "Generated by AI."
            
        return DiagramResult(
            success=True,
            format=output_format,
            ascii_output=ascii_out if output_format == DiagramFormat.ASCII else None,
            content=mermaid_out if output_format == DiagramFormat.MERMAID else None,
            explanation=explanation
        )

    def _build_design_prompt(self, topic: str, output_format: DiagramFormat) -> str:
        """Build the prompt for AI architecture design."""
        format_req = "ASCII Art diagram" if output_format == DiagramFormat.ASCII else "Mermaid.js diagram syntax"
        
        prompt = f"""Design a DevOps architecture for the following topic: {topic}
        
        Requirements:
        1. Provide a clear {format_req}.
        2. Provide a brief educational explanation of the architecture.
        3. Format your response with clearly marked blocks:
           [ASCII] or [MERMAID] for the diagram code.
           [EXPLANATION] for the educational text.
        """
        
        if output_format == DiagramFormat.ASCII:
            prompt += "\nFor ASCII, use standard box-drawing characters or simple symbols (+, -, |) and keep it readable in a 80-character wide terminal."
            
        return prompt

    def _extract_block(self, text: str, block_type: str) -> Optional[str]:
        """Extract a marked block from AI response."""
        import re
        pattern = f"\\[{block_type.upper()}\\](.*?)(?=\\[|$)"
        match = re.search(pattern, text, re.DOTALL | re.IGNORECASE)
        return match.group(1).strip() if match else None
    
    def _generate_ascii(
        self,
        pattern: ArchitecturePattern,
        include_explanation: bool
    ) -> DiagramResult:
        """Generate ASCII art diagram."""
        ascii_generators = {
            ArchitecturePattern.MICROSERVICES: self.ascii_generator.microservices,
            ArchitecturePattern.CICD_PIPELINE: self.ascii_generator.cicd_pipeline,
            ArchitecturePattern.KUBERNETES: self.ascii_generator.kubernetes_cluster,
            ArchitecturePattern.THREE_TIER: self.ascii_generator.three_tier,
            ArchitecturePattern.SERVERLESS: self.ascii_generator.serverless,
            ArchitecturePattern.EVENT_DRIVEN: self.ascii_generator.event_driven,
        }
        
        generator = ascii_generators.get(pattern)
        if not generator:
            return DiagramResult(
                success=False,
                format=DiagramFormat.ASCII,
                error=f"No ASCII generator for pattern: {pattern.value}"
            )
        
        ascii_output = generator()
        explanation = self._get_explanation(pattern) if include_explanation else ""
        
        return DiagramResult(
            success=True,
            format=DiagramFormat.ASCII,
            ascii_output=ascii_output,
            explanation=explanation
        )
    
    def _generate_mermaid(
        self,
        pattern: ArchitecturePattern,
        include_explanation: bool
    ) -> DiagramResult:
        """Generate Mermaid diagram syntax."""
        mermaid_templates = {
            ArchitecturePattern.MICROSERVICES: """
graph TB
    Users[Users] --> LB[Load Balancer]
    LB --> Gateway[API Gateway]
    Gateway --> Auth[Auth Service]
    Gateway --> User[User Service]
    Gateway --> Order[Order Service]
    Auth --> AuthDB[(Auth DB)]
    User --> UserDB[(User DB)]
    Order --> OrderDB[(Order DB)]
    User --> Queue[Message Queue]
    Order --> Queue
    Queue --> Notify[Notification Service]
""",
            ArchitecturePattern.CICD_PIPELINE: """
graph LR
    Dev[Developer] -->|git push| Repo[Git Repository]
    Repo -->|webhook| CI[CI Server]
    CI --> Build[Build & Test]
    Build --> Docker[Build Image]
    Docker --> Registry[Container Registry]
    Registry --> Staging[Deploy Staging]
    Staging --> Tests[Integration Tests]
    Tests -->|approval| Prod[Deploy Production]
    Prod --> Monitor[Monitoring]
""",
            ArchitecturePattern.THREE_TIER: """
graph TB
    subgraph Presentation
        Web[Web App]
        Mobile[Mobile App]
    end
    subgraph Application
        LB[Load Balancer]
        App1[App Server 1]
        App2[App Server 2]
        App3[App Server 3]
    end
    subgraph Data
        Primary[(Primary DB)]
        Replica1[(Replica 1)]
        Replica2[(Replica 2)]
    end
    Web --> LB
    Mobile --> LB
    LB --> App1
    LB --> App2
    LB --> App3
    App1 --> Primary
    App2 --> Primary
    App3 --> Primary
    Primary --> Replica1
    Primary --> Replica2
""",
        }
        
        mermaid_code = mermaid_templates.get(pattern, "graph TB\n    A[No template available]")
        explanation = self._get_explanation(pattern) if include_explanation else ""
        
        return DiagramResult(
            success=True,
            format=DiagramFormat.MERMAID,
            ascii_output=mermaid_code,
            explanation=explanation
        )
    
    def _generate_image(
        self,
        pattern: ArchitecturePattern,
        output_format: DiagramFormat,
        output_path: Optional[str],
        include_explanation: bool
    ) -> DiagramResult:
        """Generate PNG/SVG diagram using diagrams library."""
        deps = self._check_dependencies()
        
        if not deps["diagrams"]:
            return DiagramResult(
                success=False,
                format=output_format,
                error="diagrams library not installed. Run: pip install diagrams"
            )
        
        if not deps["graphviz"]:
            return DiagramResult(
                success=False,
                format=output_format,
                error="graphviz not installed. Run: apt-get install graphviz (or brew install graphviz on Mac)"
            )
        
        try:
            from diagrams import Diagram, Cluster, Edge
            from diagrams.onprem.client import Users
            from diagrams.onprem.compute import Server
            from diagrams.onprem.database import PostgreSQL, MongoDB
            from diagrams.onprem.network import Nginx
            from diagrams.onprem.queue import RabbitMQ
            
            # Set output path
            if not output_path:
                output_path = f"{pattern.value}_architecture"
            
            # Remove extension if provided (diagrams adds it)
            output_path = output_path.replace('.png', '').replace('.svg', '')
            
            # Generate based on pattern
            if pattern == ArchitecturePattern.MICROSERVICES:
                with Diagram(
                    "Microservices Architecture",
                    filename=output_path,
                    show=False,
                    direction="TB"
                ):
                    users = Users("Users")
                    lb = Nginx("Load Balancer")
                    gateway = Server("API Gateway")
                    
                    with Cluster("Services"):
                        auth = Server("Auth Service")
                        user_svc = Server("User Service")
                        order_svc = Server("Order Service")
                        services = [auth, user_svc, order_svc]
                    
                    queue = RabbitMQ("Message Queue")
                    notify = Server("Notification")
                    
                    with Cluster("Databases"):
                        auth_db = PostgreSQL("Auth DB")
                        user_db = MongoDB("User DB")
                        order_db = PostgreSQL("Order DB")
                    
                    users >> lb >> gateway
                    gateway >> services
                    auth >> auth_db
                    user_svc >> user_db
                    order_svc >> order_db
                    services >> queue >> notify
            
            else:
                return DiagramResult(
                    success=False,
                    format=output_format,
                    error=f"Image generation not yet implemented for: {pattern.value}"
                )
            
            # Diagrams library creates .png by default
            generated_file = f"{output_path}.png"
            
            explanation = self._get_explanation(pattern) if include_explanation else ""
            
            return DiagramResult(
                success=True,
                format=output_format,
                filepath=generated_file,
                explanation=explanation
            )
            
        except Exception as e:
            return DiagramResult(
                success=False,
                format=output_format,
                error=f"Error generating diagram: {str(e)}"
            )
    
    def _get_explanation(self, pattern: ArchitecturePattern) -> str:
        """Get educational explanation for architecture pattern."""
        return get_explanation(pattern)
    
    def list_available_patterns(self) -> List[Tuple[str, str]]:
        """List all available architecture patterns."""
        return [
            (pattern.value, pattern.value.replace('_', ' ').title())
            for pattern in ArchitecturePattern
        ]

    # ------------------------------------------------------------------
    # üß† Concept Visual Models (For explain command learning topics)
    # ------------------------------------------------------------------

    def generate_concept_visual(self, topic: str) -> DiagramResult:
        """
        Generate a visual model for general DevOps concepts
        (used by 'explain' command, not architecture design).
        """
        topic = topic.lower()

        if "linux" in topic:
            return DiagramResult(
                success=True,
                format=DiagramFormat.ASCII,
                ascii_output=self._linux_visual(),
                explanation="üß† Visual model of how Linux is structured internally."
            )

        if "container" in topic:
            return DiagramResult(
                success=True,
                format=DiagramFormat.ASCII,
                ascii_output=self._container_visual(),
                explanation="üß† Visual model showing how containers isolate applications."
            )

        return DiagramResult(
            success=False,
            format=DiagramFormat.ASCII,
            error="No visual model available for this topic yet."
        )

    def _linux_visual(self) -> str:
        return """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     LINUX SYSTEM MODEL                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

User
  ‚îÇ
  ‚ñº
Shell (bash / zsh)
  ‚îÇ
  ‚ñº
Linux Kernel
  ‚îÇ
  ‚ñº
Hardware (CPU, RAM, Disk)

Filesystem Structure:
/
‚îú‚îÄ‚îÄ home   ‚Üí user files
‚îú‚îÄ‚îÄ etc    ‚Üí configuration
‚îú‚îÄ‚îÄ var    ‚Üí logs & runtime data
‚îú‚îÄ‚îÄ usr    ‚Üí applications
‚îî‚îÄ‚îÄ bin    ‚Üí system commands

Key Idea:
Everything in Linux is a file.
The kernel controls access to hardware.
"""

    def _container_visual(self) -> str:
        return """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     CONTAINERIZATION MODEL                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

                 Host OS
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ               Docker Engine                 ‚îÇ
  ‚îÇ                                             ‚îÇ
  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
  ‚îÇ  ‚îÇ  Container 1 ‚îÇ  ‚îÇ  Container 2 ‚îÇ        ‚îÇ
  ‚îÇ  ‚îÇ  App + Libs  ‚îÇ  ‚îÇ  App + Libs  ‚îÇ        ‚îÇ
  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
  ‚îÇ                                             ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Each container:
- Has its own filesystem
- Has isolated processes
- Shares the host kernel

Image ‚Üí Blueprint
Container ‚Üí Running instance
Registry ‚Üí Storage for images
"""


def format_diagram_result(result: DiagramResult, mode=None) -> str:
    """Format diagram result for display."""
    output = []
    
    if not result.success:
        output.append("‚ùå Failed to generate diagram")
        output.append(f"Error: {result.error}")
        return "\n".join(output)
    
    # Show ASCII output if available
    if result.ascii_output:
        output.append(result.ascii_output)
    
    # Show file path if generated
    if result.filepath:
        output.append(f"\n‚úÖ Diagram saved to: {result.filepath}")
    
    # Add explanation
    if result.explanation:
        output.append("\n" + "=" * 70)
        output.append(result.explanation)
    
    return "\n".join(output)


# Example usage
if __name__ == "__main__":
    visualizer = ArchitectureVisualizer()
    
    print("üé® Testing ArchitectureVisualizer Module\n")
    print("=" * 70)
    
    # Test ASCII generation
    print("\n1. Generating Microservices Architecture (ASCII)...")
    result = visualizer.generate(
        ArchitecturePattern.MICROSERVICES,
        DiagramFormat.ASCII,
        include_explanation=True
    )
    print(format_diagram_result(result))
    
    print("\n" + "=" * 70)
    print("\n2. Available Patterns:")
    for value, name in visualizer.list_available_patterns():
        print(f"   - {name} ({value})")